#!/bin/bash

#
# General
# ---------------------------------------------------

# Create a data URI from a file
datauri() {
    local mimeType=""

    if [ -f "$1" ]; then
        mimeType=$(file -b --mime-type "$1")
        #                └─ do not prepend the filename to the output

        if [[ $mimeType == text/* ]]; then
            mimeType="$mimeType;charset=utf-8"
        fi

        printf "data:%s;base64,%s" \
                    "$mimeType" \
                    "$(openssl base64 -in "$1" | tr -d "\n")"
    else
        print_error "'$1' is not a file."
    fi
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
    local tmpFile="${@%/}.tar"
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    )

    local cmd=""
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli"
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz"
        else
            cmd="gzip"
        fi
    fi

    echo "Compressing .tar using \`${cmd}\`…"
    "${cmd}" -v "${tmpFile}" || return 1
    [ -f "${tmpFile}" ] && rm "${tmpFile}"
    echo "${tmpFile}.gz created successfully."
}

# Delete all files that match a certain pattern from the current directory
deletefiles() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# Create new directories and enter the first one
mkd() {
    if [ -n "$*" ]; then
        mkdir -p "$@" && cd "$@"
        #      └─ make parent directories if needed
    fi
}

# Remove directories and echo a message
rmd() {
    rm -r "$@"
}

# Search History
qh() {
    #                                 ┌─ enable colors for pipe
    #                                 │  ("--color=auto" enables colors only if
    #                                 │  the output is in the terminal)
    cat ~/.bash_history | grep --color=always "$*" | less -RX
    # display the ANSI color escape sequences in raw form ─┘│
    #           don't clear the screen after quitting less ─┘
}

# Search for text within the current directory
qt() {
    grep -ir --color=always "$*" . | less -RX
    #     │└─ search all files under each directory, recursively
    #     └─ ignore case
}

# Copy
cpd() {
  pwd | tr -d "\r\n" | pbcopy
}

cpf() {
  [[ "$#" != 1 ]] && return 1
  local file_to_copy=$1
  cat $file_to_copy | pbcopy
}

# Open Dash App
dash() {
    open dash://"$@"
}

# Making a script executable
scr() {
    chmod u+x "$@" && ./"$@"
}

# StackOverflow
showme(){
    open http://stackoverflow.com/search?q="$@"
}


#
# Development (based on my workflow)
# ---------------------------------------------------

# Shortcut to General Projects
dev() {
    cd Sites/projects/"$@"
    # subl .
}

# Shortcut to Respositories
repos() {
    cd Sites/@mylabs/"$1"/"$2"
    # subl .
}

# Shortcut to WordPress Projects
wp() {
    cd Sites/projects/"$1"/wp-content/themes/"$2"
    # subl .
}


# Clones a personal repository, cds into it, asks for install node modules and create executable script.
# - arg 1 - name of repository
clone() {
    local repo=$1;
    local npm=$2;
    local scr=$3;

    # Install Node Modules
    if [[ -f package.json ]]; then
        npm=npm install
    fi

    # Make a script executable
    if [[ -f $repo.sh ]]; then
        src=chmod u+x $repo.sh
    elif [[ -f $repo.js ]]; then
        src=chmod u+x $repo.js
    fi

    # Initialize Clone
    git clone git://github.com/vitorbritto/$repo.git && cd $repo && $npm && $src;

    # All done!
    echo -n "✔ done!"
}


# Server
# -------------------

# Apache
apache() {
    sudo -v # Ask for the administrator password upfront
    apachectl $@ # options: start, stop or restart
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver() {
    local port="${1:-4000}"
    local ip=$(ipconfig getifaddr en1)
    sleep 1 && open "http://${ip}:${port}/" &
    php -S "${ip}:${port}"
}
